// 01 create a counter that start at 0 
// increment the counter by 1 

// let i = 0;
// function increment (){
//   i ++; 
//   console.log(i)
// }
// setInterval(increment, 1000)

// ++counter VS counter ++ 
// closure - when a variable is defined in the outer function that are used in the inner function long after the outer function has been return, (variable still remember in the memory)
// memory leaks - using more variable 
function outer(){
  var count = 0; 
  var instructor = "Elie";
  return function inner(){
    debugger
    return count // this is an example of closure cause you are using variable from outer function
  }
}

// better example 
function counter(){
  var count = 0;
  return function inner(){
    return ++count

  }
}
var counter1 = counter(); 
counter1();
///ReactJS - export default connect(mapStateToProps, mapDispatchToProps)(Todo) // good example of closure
///NodeJS - var express = require("express") 
//          var app = express()

///////////////////////////////////////////////////////////////////////////////////////////////////
//02 Array Method 
// return a new array with all the values doubled 

let arr = [1, 2, 3, 4];
const doubled = arr.map(el => {
  return el * 2;
});
console.log(doubled);
console.log(arr)

// a different way 
// using map will return a new array
function doubleWithLoop(arr){
  var newArr = [];
  for(var i = 0; i < arr.length; i ++) {
    newArr.push(arr[i]*2);
  };
  return newArr
};

function doubleWithMap(arr){
    return arr.map(function(val){
      return val * 2
    })
  };

// declaration - only result --> use map 
// imperative - step by step, procedural --> using loop approach

// 03 reduce 
// you can turn the variable into different kind of data structure 
//// example 1
[1, 2, 3, 4].reduce(function(accumulator, nextValue) {
  return accumulator += nextValue;
}, 0);
/// example 2
[1, 2, 3, 4].reduce(function (accumulator, nextValue) {
  if (nextValue % 2 === 0) {
    accumulator.push(nextValue);
  };
  return accumulator
}, []);
//// example 3
[1, 2, 3, 4, 3, 2, 0].reduce(function (accumulator, nextValue) {
  if (nextValue in accumulator) {
    accumulator[nextValue]++;
  }else {
    accumulator[nextValue] = 1;
  };
  return accumulator
}, []);

/// 04 THIS 
// refers to global object
/// when you have an invoked function, you will have "this" and "arguments"
///example 1
function awesome(){
  return this 
} /// you have no idea what it refers until you see the action invoke
awesome() // window 
new awesome() // object
awesome.call([]) // []
awesome.call({}); // {}

/////example 2
var obj = {
  firstName: "Elie",
  sayHi: function(){
    return `Hello ${this.firstName}`
  }
}

//// example 3 - explicit
var instructor = {
  firstName: "Elie",
  sayHi: function () {
    return `Hello ${this.firstName}`
  }
}

var instructor2 = {
  firstName: "Matt";
}

instructor.sayHi() // currently this is referring to instructor
instructor.sayHi().call(instructor2) // currently this is referring to instructor2 

/// better version
var instructor = {
  firstName: "Elie",
  lastName: "Mike"
}

var instructor2 = {
  firstName: "Matt";
  lastName: "Oral"
}

function sayHi(){
    return `Hello ${this.firstName}`
}

sayHi.call(instructor); // "hello ellie";
sayHi.call(instructor2); // "hello Matt";

// CALL AND BIND
sayHi.call(instructor, 1, 2, 3) // when you pass argument
sayHi.apply(instructor, [1, 2, 3]) // when you pass an array

Math.max([1,2,3,10]) // Nan 
Math.max.apply(this, [1, 2, 3, 10]) // 10
Math.max(...[1,2,3, 10]) // spread operator // 10
//// bind - implemented through closure
var instructor = {
  firstName: "Elie"
}
function doMath(a, b, c) {
  return `${this.firstName} adds ${a +b +c}` 
}
var invokeLater = doMath.bind(instructor, 2) 
invokeLater(10, 20) /// "Elie adds 32"
///currying - calls the function over and over again until all the arguments are passed in

/// global object - when the keyword is declared in an child object, its going to refer to the parent object
/// implicit 
/// explicit 
/// new 

var obj = {
  firstName: "Elie",
  sayHi: function(){
    setTimeout(function(){
      console.log(`Hello ${this.firstName}`)
    }, 1000)
  }
}

obj.sayHi(); // Hello undefined 

/// ES5 Way
var obj = {
  firstName: "Elie",
  sayHi: function () {
    setTimeout(() => {
      console.log(`Hello ${this.firstName}`)
    }, 1000)
  }
}

obj.sayHi(); // Hello Elie

/// Using bind
var obj = {
  firstName: "Elie",
  sayHi: function () {
    setTimeout(function() {
      console.log(`Hello ${this.firstName}`)
    }.bind(obj), 1000)
  }
}

obj.sayHi(); // Hello Elie

// Using bind and this
var obj = {
  firstName: "Elie",
  sayHi: function () {
    setTimeout(function () {
      console.log(`Hello ${this.firstName}`)
    }.bind(this), 1000)
  }
}

obj.sayHi(); // Hello Elie